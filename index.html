<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Checker</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><radialGradient id='g' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' stop-color='%23fff' stop-opacity='0.9'/><stop offset='30%25' stop-color='%23ffa500'/><stop offset='70%25' stop-color='%23e65c00'/><stop offset='100%25' stop-color='%23e65c00' stop-opacity='0'/></radialGradient><radialGradient id='glow' cx='50%25' cy='50%25' r='50%25'><stop offset='60%25' stop-color='%23ffa500' stop-opacity='0.4'/><stop offset='100%25' stop-color='%23ffa500' stop-opacity='0'/></radialGradient></defs><circle cx='50' cy='50' r='48' fill='url(%23glow)'/><circle cx='50' cy='50' r='30' fill='url(%23g)'/></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 { font-size: 1.5rem; color: #fff; margin-bottom: 8px; }
    .subtitle { font-size: 0.85rem; color: #666; margin-bottom: 24px; }

    textarea {
      width: 100%; height: 150px; padding: 14px;
      font-family: monospace; font-size: 0.9rem;
      border: 1px solid #333; border-radius: 8px;
      background: #1a1a1a; color: #fff;
      outline: none; resize: vertical;
    }
    textarea:focus { border-color: #555; }
    textarea::placeholder { color: #555; }

    .btn-row { margin-top: 16px; display: flex; gap: 12px; }

    button {
      padding: 12px 24px; font-size: 1rem; font-weight: 600;
      border: none; border-radius: 6px; cursor: pointer;
      transition: background 0.15s;
    }

    #check-btn { background: #3a7bd5; color: #fff; }
    #check-btn:hover { background: #2a6bc5; }
    #check-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

    #clear-btn { background: #333; color: #aaa; }
    #clear-btn:hover { background: #444; color: #fff; }

    .filter-btn { background: #333; color: #aaa; }
    .filter-btn:hover { background: #444; color: #fff; }
    .filter-btn.active { background: #e54; color: #fff; }

    .download-btn { background: #2a8a4a; color: #fff; }
    .download-btn:hover { background: #238a3a; }
    .download-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

    .single-download-btn { background: #3a7bd5; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .single-download-btn:hover { background: #2a6bc5; }

    .vinyl-btn { background: #9333ea; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .vinyl-btn:hover { background: #7e22ce; }

    .cd-btn { background: #0891b2; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .cd-btn:hover { background: #0e7490; }

    .square-btn { background: #ea580c; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .square-btn:hover { background: #c2410c; }

    .resize-btn { background: #059669; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .resize-btn:hover { background: #047857; }

    .convert-png-btn { background: #6366f1; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .convert-png-btn:hover { background: #4f46e5; }

    .actually-fine-btn { background: #16a34a; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .actually-fine-btn:hover { background: #15803d; }

    .mark-wrong-btn { background: #dc2626; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .mark-wrong-btn:hover { background: #b91c1c; }

    .save-later-btn { background: #ca8a04; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .save-later-btn:hover { background: #a16207; }

    .view-original-btn { background: #7c3aed; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .view-original-btn:hover { background: #6d28d9; }

    .remove-bg-btn { background: #ec4899; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .remove-bg-btn:hover { background: #db2777; }
    .remove-bg-btn:disabled { background: #6b7280; cursor: wait; }

    .image-actions { display: flex; flex-wrap: wrap; gap: 4px; }

    .product-type { font-size: 0.7rem; margin-top: 4px; }
    .product-type .badge { margin-left: 0; }

    #status {
      margin-top: 16px; font-size: 0.85rem; color: #888;
      min-height: 24px;
    }

    #filter-row {
      display: none; margin-top: 16px; gap: 12px;
      align-items: center; flex-wrap: wrap;
    }
    #filter-row.visible { display: flex; }

    #results { margin-top: 24px; }

    .product-card.hidden { display: none; }

    .product-card {
      background: #1a1a1a; border-radius: 8px;
      padding: 16px; margin-bottom: 12px;
      border: 1px solid #333;
    }

    .product-card.has-issues { border-color: #e54; }
    .product-card.all-good { border-color: #2a8a4a; }

    .product-header {
      display: flex; gap: 16px; margin-bottom: 12px;
    }

    .product-thumb {
      width: 200px; height: 200px; border-radius: 4px;
      object-fit: contain; background: #252525; flex-shrink: 0;
    }

    .product-info { flex: 1; min-width: 0; }

    .product-title {
      font-size: 1rem; font-weight: 600; color: #fff;
      margin-bottom: 4px; overflow: hidden;
      text-overflow: ellipsis; white-space: nowrap;
    }

    .product-url {
      font-size: 0.75rem; color: #666; font-family: monospace;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }

    .product-url a { color: #3a7bd5; text-decoration: none; }
    .product-url a:hover { text-decoration: underline; }

    .image-list { margin-top: 12px; }

    .image-item {
      display: flex; align-items: center; gap: 12px;
      padding: 10px; background: #111; border-radius: 6px;
      margin-bottom: 8px; font-size: 0.85rem;
    }

    .image-thumb {
      width: 50px; height: 50px; border-radius: 4px;
      object-fit: cover; background: #252525; flex-shrink: 0;
    }

    .image-details { flex: 1; }

    .image-filename {
      color: #aaa; font-family: monospace; font-size: 0.75rem;
      margin-bottom: 4px; word-break: break-all;
    }

    .image-meta { display: flex; gap: 16px; flex-wrap: wrap; }

    .meta-item { display: flex; align-items: center; gap: 4px; }
    .meta-label { color: #666; }
    .meta-value { color: #fff; font-weight: 500; }

    .badge {
      padding: 2px 8px; border-radius: 4px;
      font-size: 0.7rem; font-weight: 600;
      text-transform: uppercase;
    }

    .badge-ok { background: rgba(42, 138, 74, 0.2); color: #4eca7a; }
    .badge-warn { background: rgba(238, 170, 68, 0.2); color: #eaa844; }
    .badge-error { background: rgba(238, 85, 68, 0.2); color: #e54; }

    .issues-list {
      margin-top: 8px; padding: 10px;
      background: rgba(238, 85, 68, 0.1);
      border-radius: 6px; border-left: 3px solid #e54;
    }

    .issue {
      font-size: 0.85rem; color: #e54;
      padding: 4px 0;
    }

    .summary {
      background: #1a1a1a; border-radius: 8px;
      padding: 16px; margin-bottom: 24px;
      display: flex; gap: 24px; flex-wrap: wrap;
    }

    .summary-stat {
      text-align: center;
    }

    .summary-num {
      font-size: 2rem; font-weight: 700; color: #fff;
    }

    .summary-num.errors { color: #e54; }
    .summary-num.warnings { color: #eaa844; }
    .summary-num.good { color: #4eca7a; }

    .summary-label { font-size: 0.8rem; color: #666; }

    .loading { color: #888; font-style: italic; }

    /* Modal for viewing original image */
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.9); z-index: 1000;
      display: none; align-items: center; justify-content: center;
      padding: 20px;
    }
    .modal-overlay.visible { display: flex; }
    .modal-content {
      position: relative; max-width: 95vw; max-height: 95vh;
    }
    .modal-image {
      max-width: 95vw; max-height: 90vh; object-fit: contain;
      border-radius: 8px; background: #252525;
    }
    .modal-close {
      position: absolute; top: -40px; right: 0;
      background: #e54; color: #fff; border: none;
      padding: 8px 16px; border-radius: 4px; cursor: pointer;
      font-size: 1rem; font-weight: 600;
    }
    .modal-close:hover { background: #d43; }

    /* Saved for later panel */
    .saved-panel {
      background: #1a1a1a; border-radius: 8px;
      padding: 16px; margin-bottom: 24px;
      border: 1px solid #ca8a04; display: none;
    }
    .saved-panel.visible { display: block; }
    .saved-panel h3 { color: #ca8a04; margin-bottom: 12px; font-size: 1rem; }
    .saved-list { display: flex; flex-wrap: wrap; gap: 8px; }
    .saved-item {
      display: flex; align-items: center; gap: 8px;
      background: #252525; padding: 8px 12px; border-radius: 6px;
    }
    .saved-item img { width: 40px; height: 40px; object-fit: cover; border-radius: 4px; cursor: pointer; }
    .saved-item-info { font-size: 0.75rem; color: #aaa; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .saved-item-remove { background: #dc2626; color: #fff; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; }
    .saved-item-remove:hover { background: #b91c1c; }

    .expand-saved-btn { background: #ca8a04; color: #fff; font-size: 0.8rem; padding: 6px 12px; }
    .expand-saved-btn:hover { background: #a16207; }

    /* Expanded work mode */
    .saved-list.expanded { flex-direction: column; }
    .saved-list.expanded .saved-item {
      flex-direction: column; align-items: flex-start;
      padding: 16px; gap: 12px;
    }
    .saved-list.expanded .saved-item img {
      width: 300px; height: 300px; object-fit: contain;
      background: #1a1a1a; border: 1px solid #333;
    }
    .saved-list.expanded .saved-item-info {
      max-width: none; font-size: 0.85rem; color: #ccc;
    }
    .saved-list.expanded .saved-item-actions {
      display: flex; flex-wrap: wrap; gap: 4px;
    }
    .saved-item-actions { display: none; }
    .saved-list.expanded .saved-item-actions { display: flex; }

    .view-saved-btn { background: #ca8a04; color: #fff; }
    .view-saved-btn:hover { background: #a16207; }

    .find-image-btn { background: #be185d; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .find-image-btn:hover { background: #9d174d; }

    .check-other-store-btn { background: #0d9488; color: #fff; font-size: 0.75rem; padding: 6px 10px; margin-top: 8px; }
    .check-other-store-btn:hover { background: #0f766e; }
    .check-other-store-btn.different-image { background: #16a34a; }
    .check-other-store-btn.different-image:hover { background: #15803d; }
    .check-other-store-btn.same-image { background: #6b7280; }
    .check-other-store-btn.same-image:hover { background: #4b5563; }

    .other-store-status { font-size: 0.7rem; color: #666; margin-top: 4px; }
    .other-store-status.checking { color: #888; font-style: italic; }
    .other-store-status.not-found { color: #666; }

    .product-actions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px; align-items: center; }

    .clear-saved-btn { background: #dc2626; color: #fff; font-size: 0.8rem; padding: 6px 12px; margin-left: auto; }
    .clear-saved-btn:hover { background: #b91c1c; }

    .saved-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }

    .marked-badge {
      display: inline-block; padding: 2px 6px; border-radius: 4px;
      font-size: 0.65rem; font-weight: 600; margin-left: 8px;
    }
    .marked-fine { background: rgba(22, 163, 74, 0.2); color: #4ade80; }
    .marked-wrong { background: rgba(220, 38, 38, 0.2); color: #f87171; }
    .marked-later { background: rgba(202, 138, 4, 0.2); color: #fbbf24; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Image Checker</h1>
    <p class="subtitle">Paste collection URLs from uDiscover or The Sound of Vinyl (one per line) to check all product images.</p>

    <textarea id="urls" placeholder="https://shop.udiscovermusic.com/collections/soldouttest
https://thesoundofvinyl.us/collections/low-inventory
..."></textarea>

    <div class="btn-row">
      <button id="check-btn" onclick="checkImages()">Check Images</button>
      <button id="clear-btn" onclick="clearAll()">Clear</button>
    </div>

    <div id="filter-row">
      <button class="filter-btn" id="filter-issues-btn" onclick="toggleFilter()">Show Only Issues</button>
      <button class="download-btn" id="download-btn" onclick="downloadIssueImages()">Download All</button>
      <button class="view-saved-btn" id="view-saved-btn" onclick="toggleSavedPanel()">View Saved (<span id="saved-count">0</span>)</button>
    </div>

    <div id="saved-panel" class="saved-panel">
      <div class="saved-header">
        <h3>Saved for Later</h3>
        <button class="expand-saved-btn" id="expand-saved-btn" onclick="toggleExpandSaved()">Work on These</button>
        <button class="clear-saved-btn" onclick="clearSavedLater()">Clear All</button>
      </div>
      <div id="saved-list" class="saved-list"></div>
    </div>

    <div id="status"></div>
    <div id="results"></div>
  </div>

  <!-- Modal for viewing original image -->
  <div id="image-modal" class="modal-overlay" onclick="closeModal(event)">
    <div class="modal-content">
      <button class="modal-close" onclick="closeModal()">Close</button>
      <img id="modal-image" class="modal-image" src="" alt="Original image">
    </div>
  </div>

  <script>
    // Background removal library - loaded on demand
    let bgRemovalLoaded = false;

    const MIN_SIZE = 801;
    const MAX_SIZE = 1199;

    const KNOWN_SHOPS = {
      'shop.udiscovermusic.com': 'https://shop.udiscovermusic.com',
      'thesoundofvinyl.us': 'https://thesoundofvinyl.us'
    };

    function detectShopBase(url) {
      try {
        const host = new URL(url).hostname;
        return KNOWN_SHOPS[host] || null;
      } catch {
        return null;
      }
    }

    function getOtherStoreName(productUrl) {
      const isUdiscover = productUrl.includes('shop.udiscovermusic.com');
      return isUdiscover ? 'üè™ Check Sound of Vinyl' : 'üè™ Check uDiscover';
    }

    function findHiResImage(productTitle) {
      // Build Google Images search URL excluding uDiscover and Sound of Vinyl
      const query = encodeURIComponent(`${productTitle} album cover -site:shop.udiscovermusic.com -site:thesoundofvinyl.us -site:udiscovermusic.com`);
      const googleUrl = `https://www.google.com/search?tbm=isch&q=${query}&tbs=isz:l`;
      window.open(googleUrl, '_blank');
    }

    function checkOtherStore(productTitle, currentUrl) {
      const isUdiscover = currentUrl.includes('shop.udiscovermusic.com');
      const otherStoreBase = isUdiscover
        ? 'https://thesoundofvinyl.us'
        : 'https://shop.udiscovermusic.com';

      // Search the other store for this product
      const searchQuery = encodeURIComponent(productTitle);
      const searchUrl = `${otherStoreBase}/search?q=${searchQuery}`;
      window.open(searchUrl, '_blank');
    }

    function viewOtherStoreProduct(otherStoreUrl) {
      window.open(otherStoreUrl, '_blank');
    }

    // Cache for other store lookups
    const otherStoreCache = new Map();

    async function checkProductOnOtherStore(product) {
      const isUdiscover = product.url.includes('shop.udiscovermusic.com');
      const otherStoreBase = isUdiscover
        ? 'https://thesoundofvinyl.us'
        : 'https://shop.udiscovermusic.com';
      const otherStoreName = isUdiscover ? 'Sound of Vinyl' : 'uDiscover';

      const cacheKey = `${product.handle}-${otherStoreBase}`;
      if (otherStoreCache.has(cacheKey)) {
        return otherStoreCache.get(cacheKey);
      }

      // Generate handle variations to try (with/without format suffixes)
      const formatSuffixes = ['-lp', '-vinyl', '-cd', '-2lp', '-3lp', '-1lp'];
      const baseHandle = product.handle.replace(new RegExp(`(${formatSuffixes.join('|')})$`), '');
      const handleVariations = [
        product.handle,
        baseHandle,
        ...formatSuffixes.map(suffix => baseHandle + suffix)
      ];
      // Remove duplicates
      const uniqueHandles = [...new Set(handleVariations)];

      try {
        // Try to find product by handle variations
        for (const handle of uniqueHandles) {
          const handleUrl = `${otherStoreBase}/products/${handle}.json`;
          let response = await fetch(handleUrl);

          if (response.ok) {
            const data = await response.json();
            const otherProduct = data.product;
            const result = {
              found: true,
              otherStoreName,
              otherStoreUrl: `${otherStoreBase}/products/${handle}`,
              otherProduct,
              imageDifferent: checkImagesDifferent(product, otherProduct)
            };
            otherStoreCache.set(cacheKey, result);
            return result;
          }
        }

        // If not found by handle, search by title
        // Strip format info from title for better matching
        const cleanTitle = product.title
          .replace(/\s*[\[\(].*?[\]\)]\s*/g, '') // Remove bracketed content
          .replace(/\s*(LP|CD|Vinyl|2LP|3LP|1LP)\s*$/i, '') // Remove format suffix
          .trim();

        const searchUrl = `${otherStoreBase}/search/suggest.json?q=${encodeURIComponent(cleanTitle)}&resources[type]=product&resources[limit]=10`;
        let response = await fetch(searchUrl);

        if (response.ok) {
          const data = await response.json();
          const products = data.resources?.results?.products || [];

          // Normalize title for comparison
          const normalizeTitle = (t) => t.toLowerCase()
            .replace(/\s*[\[\(].*?[\]\)]\s*/g, '')
            .replace(/\s*(lp|cd|vinyl|2lp|3lp|1lp)\s*$/i, '')
            .replace(/[^a-z0-9]/g, '')
            .trim();

          const normalizedSource = normalizeTitle(product.title);

          // Find best match by normalized title
          const match = products.find(p => {
            const normalizedTarget = normalizeTitle(p.title);
            return normalizedSource === normalizedTarget ||
                   normalizedSource.includes(normalizedTarget) ||
                   normalizedTarget.includes(normalizedSource);
          });

          if (match) {
            // Fetch full product details
            const productUrl = `${otherStoreBase}/products/${match.handle}.json`;
            const productResponse = await fetch(productUrl);
            if (productResponse.ok) {
              const productData = await productResponse.json();
              const otherProduct = productData.product;
              const result = {
                found: true,
                otherStoreName,
                otherStoreUrl: `${otherStoreBase}/products/${match.handle}`,
                otherProduct,
                imageDifferent: checkImagesDifferent(product, otherProduct)
              };
              otherStoreCache.set(cacheKey, result);
              return result;
            }
          }
        }

        const result = { found: false, otherStoreName };
        otherStoreCache.set(cacheKey, result);
        return result;
      } catch (err) {
        console.error('Error checking other store:', err);
        const result = { found: false, otherStoreName, error: err.message };
        otherStoreCache.set(cacheKey, result);
        return result;
      }
    }

    function checkImagesDifferent(product1, product2) {
      if (!product1.images?.length || !product2.images?.length) return true;

      const img1 = product1.images[0];
      const img2 = product2.images[0];

      // Check dimensions
      const dim1 = `${img1.width}x${img1.height}`;
      const dim2 = `${img2.width}x${img2.height}`;
      if (dim1 !== dim2) return true;

      // Check if filenames are different (ignoring CDN path differences)
      const filename1 = img1.src?.split('/').pop()?.split('?')[0] || '';
      const filename2 = img2.src?.split('/').pop()?.split('?')[0] || '';
      if (filename1 !== filename2) return true;

      return false;
    }

    async function updateOtherStoreStatus(productHandle, product) {
      const statusEl = document.getElementById(`other-store-status-${productHandle}`);
      const btnContainer = document.getElementById(`other-store-btn-${productHandle}`);

      if (!statusEl || !btnContainer) return;

      const result = await checkProductOnOtherStore(product);

      if (result.found) {
        const btnClass = result.imageDifferent ? 'different-image' : 'same-image';
        const btnText = result.imageDifferent
          ? `‚ú® ${result.otherStoreName} (different image!)`
          : `üè™ ${result.otherStoreName} (same image)`;

        btnContainer.innerHTML = `
          <button class="check-other-store-btn ${btnClass}" onclick="viewOtherStoreProduct('${result.otherStoreUrl}')">
            ${btnText}
          </button>
        `;
        statusEl.textContent = result.imageDifferent
          ? `${result.otherProduct.images?.[0]?.width}x${result.otherProduct.images?.[0]?.height}`
          : '';
        statusEl.className = 'other-store-status';
      } else {
        btnContainer.innerHTML = '';
        statusEl.textContent = `Not on ${result.otherStoreName}`;
        statusEl.className = 'other-store-status not-found';
      }
    }

    // LocalStorage keys
    const STORAGE_KEYS = {
      ACTUALLY_FINE: 'udiscover_actually_fine',
      MARKED_WRONG: 'udiscover_marked_wrong',
      SAVED_LATER: 'udiscover_saved_later'
    };

    // Load lists from localStorage
    function loadStoredList(key) {
      try {
        return JSON.parse(localStorage.getItem(key) || '[]');
      } catch {
        return [];
      }
    }

    function saveStoredList(key, list) {
      localStorage.setItem(key, JSON.stringify(list));
    }

    function getImageKey(src) {
      // Normalize the URL to create a consistent key
      return src.split('?')[0];
    }

    function isActuallyFine(src) {
      const list = loadStoredList(STORAGE_KEYS.ACTUALLY_FINE);
      return list.includes(getImageKey(src));
    }

    function isMarkedWrong(src) {
      const list = loadStoredList(STORAGE_KEYS.MARKED_WRONG);
      return list.includes(getImageKey(src));
    }

    function isSavedForLater(src) {
      const list = loadStoredList(STORAGE_KEYS.SAVED_LATER);
      return list.some(item => item.src === getImageKey(src));
    }

    function markAsActuallyFine(src, handle) {
      const list = loadStoredList(STORAGE_KEYS.ACTUALLY_FINE);
      const key = getImageKey(src);
      if (!list.includes(key)) {
        list.push(key);
        saveStoredList(STORAGE_KEYS.ACTUALLY_FINE, list);
      }
      // Remove from marked wrong if present
      removeFromMarkedWrong(src);
      // Refresh the display
      refreshCurrentResults();
    }

    function markAsWrong(src, handle) {
      const list = loadStoredList(STORAGE_KEYS.MARKED_WRONG);
      const key = getImageKey(src);
      if (!list.includes(key)) {
        list.push(key);
        saveStoredList(STORAGE_KEYS.MARKED_WRONG, list);
      }
      // Remove from actually fine if present
      removeFromActuallyFine(src);
      // Refresh the display
      refreshCurrentResults();
    }

    function removeFromActuallyFine(src) {
      let list = loadStoredList(STORAGE_KEYS.ACTUALLY_FINE);
      const key = getImageKey(src);
      list = list.filter(k => k !== key);
      saveStoredList(STORAGE_KEYS.ACTUALLY_FINE, list);
    }

    function removeFromMarkedWrong(src) {
      let list = loadStoredList(STORAGE_KEYS.MARKED_WRONG);
      const key = getImageKey(src);
      list = list.filter(k => k !== key);
      saveStoredList(STORAGE_KEYS.MARKED_WRONG, list);
    }

    function saveForLater(src, handle, productTitle) {
      const list = loadStoredList(STORAGE_KEYS.SAVED_LATER);
      const key = getImageKey(src);
      if (!list.some(item => item.src === key)) {
        list.push({ src: key, fullSrc: src, handle, productTitle, savedAt: Date.now() });
        saveStoredList(STORAGE_KEYS.SAVED_LATER, list);
      }
      updateSavedCount();
      refreshCurrentResults();
    }

    function removeFromSavedLater(src) {
      let list = loadStoredList(STORAGE_KEYS.SAVED_LATER);
      const key = getImageKey(src);
      list = list.filter(item => item.src !== key);
      saveStoredList(STORAGE_KEYS.SAVED_LATER, list);
      updateSavedCount();
      renderSavedList();
      refreshCurrentResults();
    }

    function clearSavedLater() {
      if (confirm('Clear all saved for later items?')) {
        saveStoredList(STORAGE_KEYS.SAVED_LATER, []);
        updateSavedCount();
        renderSavedList();
        refreshCurrentResults();
      }
    }

    function updateSavedCount() {
      const list = loadStoredList(STORAGE_KEYS.SAVED_LATER);
      document.getElementById('saved-count').textContent = list.length;
    }

    function toggleSavedPanel() {
      const panel = document.getElementById('saved-panel');
      panel.classList.toggle('visible');
      if (panel.classList.contains('visible')) {
        renderSavedList();
      }
    }

    let savedExpanded = false;

    function toggleExpandSaved() {
      savedExpanded = !savedExpanded;
      const container = document.getElementById('saved-list');
      const btn = document.getElementById('expand-saved-btn');
      container.classList.toggle('expanded', savedExpanded);
      btn.textContent = savedExpanded ? 'Compact View' : 'Work on These';
      renderSavedList();
    }

    function renderSavedList() {
      const list = loadStoredList(STORAGE_KEYS.SAVED_LATER);
      const container = document.getElementById('saved-list');

      if (list.length === 0) {
        container.innerHTML = '<p style="color: #666; font-size: 0.85rem;">No items saved for later.</p>';
        return;
      }

      container.innerHTML = list.map(item => `
        <div class="saved-item">
          <img src="${item.fullSrc}" alt="" onclick="viewOriginal('${item.fullSrc}')">
          <div class="saved-item-info">${escapeHtml(item.handle)}${item.productTitle ? ' ‚Äî ' + escapeHtml(item.productTitle) : ''}</div>
          <div class="saved-item-actions">
            <button class="single-download-btn" onclick="downloadSingleImage('${item.fullSrc}', '${item.handle}', 0)">Download Original</button>
            <button class="resize-btn" onclick="downloadResizedImage('${item.fullSrc}', '${item.handle}', 0)">Download 1000x1000</button>
            <button class="remove-bg-btn" onclick="removeBackground('${item.fullSrc}', '${item.handle}', 0, this)">Remove BG</button>
            <button class="view-original-btn" onclick="viewOriginal('${item.fullSrc}')">View Original</button>
            <button class="actually-fine-btn" onclick="markAsActuallyFine('${item.fullSrc}', '${item.handle}'); removeFromSavedLater('${item.fullSrc}')">Actually Fine</button>
          </div>
          <button class="saved-item-remove" onclick="removeFromSavedLater('${item.fullSrc}')">Remove</button>
        </div>
      `).join('');
    }

    function viewOriginal(src) {
      const modal = document.getElementById('image-modal');
      const img = document.getElementById('modal-image');
      img.src = src;
      modal.classList.add('visible');
      document.body.style.overflow = 'hidden';
    }

    function closeModal(event) {
      if (event && event.target !== event.currentTarget && !event.target.classList.contains('modal-close')) {
        return;
      }
      const modal = document.getElementById('image-modal');
      modal.classList.remove('visible');
      document.body.style.overflow = '';
    }

    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeModal();
    });

    // Store last results for refresh
    let lastProductResults = [];

    function refreshCurrentResults() {
      if (lastProductResults.length > 0) {
        renderResults(lastProductResults);
      }
    }

    // Initialize saved count on page load
    document.addEventListener('DOMContentLoaded', () => {
      updateSavedCount();
    });

    async function checkImages() {
      const textarea = document.getElementById('urls');
      const status = document.getElementById('status');
      const results = document.getElementById('results');
      const btn = document.getElementById('check-btn');

      const urls = textarea.value.trim().split('\n')
        .map(u => u.trim())
        .filter(u => u.length > 0);

      if (urls.length === 0) {
        status.textContent = 'Please enter at least one URL.';
        return;
      }

      btn.disabled = true;
      results.innerHTML = '';
      status.textContent = `Fetching products from ${urls.length} collection(s)...`;

      const allProducts = [];

      // Fetch all products from all collections
      for (const url of urls) {
        try {
          const products = await fetchCollectionProducts(url);
          allProducts.push(...products);
          status.textContent = `Fetched ${allProducts.length} products so far...`;
        } catch (err) {
          allProducts.push({
            url,
            error: err.message,
            title: 'Error loading collection',
            images: []
          });
        }
      }

      status.textContent = `Checking images for ${allProducts.length} products...`;

      // Check images for each product
      const productResults = [];
      let processed = 0;

      for (const product of allProducts) {
        if (product.error) {
          productResults.push(product);
        } else {
          try {
            const result = await checkProduct(product);
            productResults.push(result);
          } catch (err) {
            productResults.push({
              url: product.url,
              error: err.message,
              title: product.title || 'Error',
              images: []
            });
          }
        }
        processed++;
        if (processed % 5 === 0 || processed === allProducts.length) {
          status.textContent = `Checking images: ${processed}/${allProducts.length} products...`;
        }
      }

      renderResults(productResults);
      btn.disabled = false;
    }

    async function fetchCollectionProducts(url) {
      // Detect shop from URL
      const shopBase = detectShopBase(url);
      if (!shopBase) {
        throw new Error('Unrecognized shop URL. Use shop.udiscovermusic.com or thesoundofvinyl.us');
      }

      // Extract collection handle from URL
      const match = url.match(/\/collections\/([^/?#]+)/);
      if (!match) {
        throw new Error('Invalid collection URL');
      }
      const handle = match[1];

      // Fetch all products (paginate if needed)
      const allProducts = [];
      let page = 1;
      const limit = 250; // Max per page

      while (true) {
        const jsonUrl = `${shopBase}/collections/${handle}/products.json?limit=${limit}&page=${page}`;
        const res = await fetch(jsonUrl);
        if (!res.ok) throw new Error(`Failed to fetch collection (${res.status})`);
        const data = await res.json();

        if (!data.products || data.products.length === 0) break;

        allProducts.push(...data.products.map(p => ({
          ...p,
          url: `${shopBase}/products/${p.handle}`,
          collectionHandle: handle
        })));

        if (data.products.length < limit) break;
        page++;
      }

      return allProducts;
    }

    function detectProductType(product) {
      const title = (product.title || '').toLowerCase();
      const tags = (product.tags || []).map(t => t.toLowerCase());
      const allText = title + ' ' + tags.join(' ');

      // Check for vinyl indicators (including 1lp, 2lp, [lp], etc.)
      const vinylKeywords = ['vinyl', ' lp', '1lp', '2lp', '3lp', '4lp', '-lp', '[lp]', '12"', '12 inch', '7"', '7 inch', '10"', '10 inch', 'record', 'pressing'];
      const isVinyl = vinylKeywords.some(kw => allText.includes(kw)) ||
                      /\blp\b/.test(allText); // Also match "lp" as whole word

      // Check for CD indicators (including 1cd, 2cd, etc.)
      const cdKeywords = [' cd', 'compact disc', '1cd', '2cd', '3cd', '4cd', '-cd'];
      const isCD = cdKeywords.some(kw => allText.includes(kw)) ||
                   /\bcd\b/.test(allText); // Also match "cd" as whole word

      if (isVinyl) return 'vinyl';
      if (isCD) return 'cd';
      return 'unknown';
    }

    async function checkProduct(product) {
      // Check each image
      const imageResults = [];
      for (const img of (product.images || [])) {
        const imgResult = await checkSingleImage(img);
        imageResults.push(imgResult);
      }

      return {
        url: product.url,
        title: product.title,
        handle: product.handle,
        featuredImage: product.images?.[0]?.src || '',
        images: imageResults,
        productType: detectProductType(product)
      };
    }

    async function checkSingleImage(img) {
      const issues = [];
      const src = img.src;
      const width = img.width;
      const height = img.height;

      // Extract filename
      const filename = src.split('/').pop().split('?')[0];
      const ext = filename.split('.').pop().toLowerCase();

      // Check format
      const isPng = ext === 'png';
      if (!isPng) {
        issues.push(`Not a PNG (found .${ext})`);
      }

      // Check dimensions (accept 801-1199 range)
      const isCorrectSize = width >= MIN_SIZE && width <= MAX_SIZE &&
                            height >= MIN_SIZE && height <= MAX_SIZE;
      if (!isCorrectSize) {
        if (width < MIN_SIZE || height < MIN_SIZE) {
          issues.push(`Too small: ${width}x${height} (minimum ${MIN_SIZE}x${MIN_SIZE})`);
        } else {
          issues.push(`Too large: ${width}x${height} (maximum ${MAX_SIZE}x${MAX_SIZE})`);
        }
      }

      // Check transparency (only for PNGs)
      let hasTransparency = null;
      if (isPng) {
        try {
          hasTransparency = await checkTransparency(src);
          if (!hasTransparency) {
            issues.push('PNG does not have transparency');
          }
        } catch (err) {
          // Can't check transparency due to CORS
          hasTransparency = 'unknown';
        }
      }

      // Check if image is square
      const isSquare = width === height;

      return {
        src,
        filename,
        width,
        height,
        format: ext.toUpperCase(),
        isPng,
        isCorrectSize,
        isSquare,
        hasTransparency,
        issues
      };
    }

    async function checkTransparency(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // Sample a smaller version for performance
            const sampleSize = Math.min(100, img.width, img.height);
            canvas.width = sampleSize;
            canvas.height = sampleSize;
            ctx.drawImage(img, 0, 0, sampleSize, sampleSize);

            const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
            const data = imageData.data;

            // Check alpha channel (every 4th byte starting at index 3)
            for (let i = 3; i < data.length; i += 4) {
              if (data[i] < 255) {
                resolve(true); // Found transparency
                return;
              }
            }
            resolve(false); // No transparency found
          } catch (err) {
            reject(err);
          }
        };
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = src;
      });
    }

    function renderResults(products) {
      const results = document.getElementById('results');
      const status = document.getElementById('status');

      // Store for refresh
      lastProductResults = products;

      let totalImages = 0;
      let imagesWithIssues = 0;
      let productsWithIssues = 0;

      products.forEach(p => {
        const hasIssues = p.error || p.images.some(img => {
          // Check if marked as actually fine (ignore issues) or marked wrong (force issues)
          if (isActuallyFine(img.src)) return false;
          if (isMarkedWrong(img.src)) return true;
          return img.issues.length > 0;
        });
        if (hasIssues) productsWithIssues++;
        p.images.forEach(img => {
          totalImages++;
          // Count issues respecting stored states
          if (isActuallyFine(img.src)) {
            // Don't count as issue
          } else if (isMarkedWrong(img.src)) {
            imagesWithIssues++;
          } else if (img.issues.length > 0) {
            imagesWithIssues++;
          }
        });
      });

      // Summary
      let html = `
        <div class="summary">
          <div class="summary-stat">
            <div class="summary-num">${products.length}</div>
            <div class="summary-label">Products checked</div>
          </div>
          <div class="summary-stat">
            <div class="summary-num">${totalImages}</div>
            <div class="summary-label">Images checked</div>
          </div>
          <div class="summary-stat">
            <div class="summary-num ${imagesWithIssues > 0 ? 'errors' : 'good'}">${imagesWithIssues}</div>
            <div class="summary-label">Images with issues</div>
          </div>
          <div class="summary-stat">
            <div class="summary-num ${productsWithIssues > 0 ? 'warnings' : 'good'}">${productsWithIssues}</div>
            <div class="summary-label">Products with issues</div>
          </div>
        </div>
      `;

      // Product cards
      products.forEach(p => {
        const hasIssues = p.error || p.images.some(img => {
          if (isActuallyFine(img.src)) return false;
          if (isMarkedWrong(img.src)) return true;
          return img.issues.length > 0;
        });
        const cardClass = p.error ? 'has-issues' : (hasIssues ? 'has-issues' : 'all-good');

        const productType = p.productType || 'unknown';
        const typeLabel = productType === 'vinyl' ? 'Vinyl' : (productType === 'cd' ? 'CD' : 'Unknown');
        const typeBadgeClass = productType === 'vinyl' ? 'ok' : (productType === 'cd' ? 'warn' : 'error');

        html += `
          <div class="product-card ${cardClass}" data-product-type="${productType}">
            <div class="product-header">
              ${p.featuredImage ? `<img class="product-thumb" src="${p.featuredImage}" alt="">` : ''}
              <div class="product-info">
                <div class="product-title">${escapeHtml(p.title)}</div>
                <div class="product-url"><a href="${p.url}" target="_blank">${p.url}</a></div>
                <div class="product-type"><span class="badge badge-${typeBadgeClass}">${typeLabel}</span></div>
                <div class="product-actions">
                  <button class="find-image-btn" onclick="findHiResImage('${escapeForAttr(p.title)}')">üîç Find Hi-Res Image</button>
                  <span id="other-store-btn-${p.handle}">
                    <span class="other-store-status checking">Checking other store...</span>
                  </span>
                </div>
                <div id="other-store-status-${p.handle}" class="other-store-status"></div>
              </div>
            </div>
        `;

        if (p.error) {
          html += `<div class="issues-list"><div class="issue">${escapeHtml(p.error)}</div></div>`;
        } else {
          html += '<div class="image-list">';
          p.images.forEach((img, idx) => {
            const sizeStatus = img.isCorrectSize ? 'ok' : 'error';
            const formatStatus = img.isPng ? 'ok' : 'error';
            let transparencyStatus = 'ok';
            let transparencyLabel = 'Yes';
            if (img.hasTransparency === false) {
              transparencyStatus = 'error';
              transparencyLabel = 'No';
            } else if (img.hasTransparency === 'unknown') {
              transparencyStatus = 'warn';
              transparencyLabel = '?';
            }

            const vinylBtn = productType === 'vinyl' ?
              `<button class="vinyl-btn" onclick="downloadVinylImage('${img.src}', '${p.handle}', ${idx})">Download 566x566 JPG</button>` : '';

            const cdBtn = productType === 'cd' ?
              `<button class="cd-btn" onclick="downloadCDImage('${img.src}', '${p.handle}', ${idx}, ${img.width}, ${img.height})">Download 553x535 JPG</button>` : '';

            const squareBtn = !img.isSquare ?
              `<button class="square-btn" onclick="downloadSquareImage('${img.src}', '${p.handle}', ${idx}, ${img.width}, ${img.height}, ${img.hasTransparency === true})">Make Square 1000x1000</button>` : '';

            const isWebp = img.format.toLowerCase() === 'webp';
            const convertPngBtn = isWebp ?
              `<button class="convert-png-btn" onclick="convertToPng('${img.src}', '${p.handle}', ${idx})">Convert to PNG</button>` : '';

            const cropStatus = img.isSquare ? 'ok' : 'error';
            const cropLabel = img.isSquare ? 'Square' : 'Bad Crop';

            // Check stored states
            const imgIsActuallyFine = isActuallyFine(img.src);
            const imgIsMarkedWrong = isMarkedWrong(img.src);
            const imgIsSavedLater = isSavedForLater(img.src);

            // Determine effective issues (respecting stored states)
            const effectiveHasIssues = imgIsMarkedWrong || (!imgIsActuallyFine && img.issues.length > 0);

            // Status badge
            let statusBadge = '';
            if (imgIsActuallyFine) {
              statusBadge = '<span class="marked-badge marked-fine">Marked Fine</span>';
            } else if (imgIsMarkedWrong) {
              statusBadge = '<span class="marked-badge marked-wrong">Marked Wrong</span>';
            }
            if (imgIsSavedLater) {
              statusBadge += '<span class="marked-badge marked-later">Saved for Later</span>';
            }

            // Action buttons based on state
            const actuallyFineBtn = effectiveHasIssues && !imgIsActuallyFine ?
              `<button class="actually-fine-btn" onclick="markAsActuallyFine('${img.src}', '${p.handle}')">Actually Fine</button>` : '';

            const markWrongBtn = !effectiveHasIssues && !imgIsMarkedWrong ?
              `<button class="mark-wrong-btn" onclick="markAsWrong('${img.src}', '${p.handle}')">Mark as Wrong</button>` : '';

            const saveLaterBtn = !imgIsSavedLater ?
              `<button class="save-later-btn" onclick="saveForLater('${img.src}', '${p.handle}', '${escapeHtml(p.title).replace(/'/g, "\\'")}')">Save for Later</button>` : '';

            const viewOriginalBtn = `<button class="view-original-btn" onclick="viewOriginal('${img.src}')">View Original</button>`;

            const removeBgBtn = (img.hasTransparency === false || !img.isPng) ?
              `<button class="remove-bg-btn" onclick="removeBackground('${img.src}', '${p.handle}', ${idx}, this)">Remove BG</button>` : '';

            html += `
              <div class="image-item">
                <img class="image-thumb" src="${img.src}" alt="" onclick="viewOriginal('${img.src}')" style="cursor: pointer;">
                <div class="image-details">
                  <div class="image-filename">${escapeHtml(img.filename)}${statusBadge}</div>
                  <div class="image-meta">
                    <div class="meta-item">
                      <span class="meta-label">Size:</span>
                      <span class="badge badge-${sizeStatus}">${img.width}x${img.height}</span>
                    </div>
                    <div class="meta-item">
                      <span class="meta-label">Format:</span>
                      <span class="badge badge-${formatStatus}">${img.format}</span>
                    </div>
                    <div class="meta-item">
                      <span class="meta-label">Transparent:</span>
                      <span class="badge badge-${transparencyStatus}">${transparencyLabel}</span>
                    </div>
                    <div class="meta-item">
                      <span class="meta-label">Crop:</span>
                      <span class="badge badge-${cropStatus}">${cropLabel}</span>
                    </div>
                  </div>
                  ${!imgIsActuallyFine && img.issues.length > 0 ? `
                    <div class="issues-list">
                      ${img.issues.map(issue => `<div class="issue">${escapeHtml(issue)}</div>`).join('')}
                    </div>
                  ` : ''}
                  ${imgIsMarkedWrong && img.issues.length === 0 ? `
                    <div class="issues-list">
                      <div class="issue">Manually marked as needing attention</div>
                    </div>
                  ` : ''}
                  <div class="image-actions">
                    <button class="single-download-btn" onclick="downloadSingleImage('${img.src}', '${p.handle}', ${idx})">Download Original</button>
                    <button class="resize-btn" onclick="downloadResizedImage('${img.src}', '${p.handle}', ${idx}, ${img.hasTransparency === true})">Download 1000x1000</button>
                    ${convertPngBtn}
                    ${removeBgBtn}
                    ${vinylBtn}
                    ${cdBtn}
                    ${squareBtn}
                    ${viewOriginalBtn}
                    ${actuallyFineBtn}
                    ${markWrongBtn}
                    ${saveLaterBtn}
                  </div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        html += '</div>';
      });

      results.innerHTML = html;
      status.textContent = `Done. ${imagesWithIssues} issue(s) found.`;

      // Show filter row
      document.getElementById('filter-row').classList.add('visible');
      document.getElementById('download-btn').disabled = imagesWithIssues === 0;

      // Check other store availability for each product (async, in background)
      products.forEach(p => {
        if (!p.error && p.handle) {
          updateOtherStoreStatus(p.handle, p);
        }
      });
    }

    function clearAll() {
      document.getElementById('urls').value = '';
      document.getElementById('results').innerHTML = '';
      document.getElementById('status').textContent = '';
      document.getElementById('filter-row').classList.remove('visible');
      filterActive = false;
      document.getElementById('filter-issues-btn').classList.remove('active');
      document.getElementById('filter-issues-btn').textContent = 'Show Only Issues';
    }

    function escapeHtml(str) {
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    function escapeForAttr(str) {
      // Escape string for use in HTML attribute (onclick handler)
      return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;');
    }

    async function downloadSingleImage(src, handle, idx) {
      try {
        const response = await fetch(src);
        const blob = await response.blob();
        const ext = src.split('.').pop().split('?')[0] || 'jpg';
        const filename = `${handle}_${idx + 1}.${ext}`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to download:', src, err);
        alert('Failed to download image');
      }
    }

    async function downloadVinylImage(src, handle, idx) {
      try {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });

        // Create canvas and resize to 566x566
        const canvas = document.createElement('canvas');
        canvas.width = 566;
        canvas.height = 566;
        const ctx = canvas.getContext('2d');

        // Fill with white background (for transparency)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, 566, 566);

        // Draw resized image
        ctx.drawImage(img, 0, 0, 566, 566);

        // Convert to JPG blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
        const filename = `${handle}_${idx + 1}_566x566.jpg`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to download vinyl image:', src, err);
        alert('Failed to download image. This may be due to CORS restrictions.');
      }
    }

    async function downloadSquareImage(src, handle, idx, origWidth, origHeight, hasTransparency = false) {
      try {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });

        // Get original format
        const ext = src.split('.').pop().split('?')[0].toLowerCase();
        const isPng = ext === 'png';
        const preserveTransparency = isPng && hasTransparency;

        // Step 1: Make square by padding (use larger dimension)
        const squareSize = Math.max(origWidth, origHeight);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = squareSize;
        tempCanvas.height = squareSize;
        const tempCtx = tempCanvas.getContext('2d');

        // Only fill with white background if NOT preserving transparency
        if (!preserveTransparency) {
          tempCtx.fillStyle = '#FFFFFF';
          tempCtx.fillRect(0, 0, squareSize, squareSize);
        }

        // Center the image
        const x = (squareSize - origWidth) / 2;
        const y = (squareSize - origHeight) / 2;
        tempCtx.drawImage(img, x, y, origWidth, origHeight);

        // Step 2: Resize to 1000x1000
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = 1000;
        finalCanvas.height = 1000;
        const finalCtx = finalCanvas.getContext('2d');

        // Only fill with white background if NOT preserving transparency
        if (!preserveTransparency) {
          finalCtx.fillStyle = '#FFFFFF';
          finalCtx.fillRect(0, 0, 1000, 1000);
        }
        finalCtx.drawImage(tempCanvas, 0, 0, 1000, 1000);

        // Use PNG format if preserving transparency
        const mimeType = preserveTransparency ? 'image/png' : (isPng ? 'image/png' : 'image/jpeg');
        const fileExt = preserveTransparency ? 'png' : (isPng ? 'png' : 'jpg');

        // Convert to blob
        const blob = await new Promise(resolve => finalCanvas.toBlob(resolve, mimeType, 0.9));
        const filename = `${handle}_${idx + 1}_1000x1000.${fileExt}`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to make square image:', src, err);
        alert('Failed to process image. This may be due to CORS restrictions.');
      }
    }

    async function downloadCDImage(src, handle, idx, origWidth, origHeight) {
      try {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });

        // Target size: 553x535
        const targetWidth = 553;
        const targetHeight = 535;

        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');

        // Fill with white background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, targetWidth, targetHeight);

        // For square images, crop from center (left and right equally)
        if (origWidth === origHeight) {
          // Calculate how much to crop from each side
          const sourceSize = origWidth;
          const cropRatio = targetWidth / targetHeight; // ~1.0336
          const sourceHeight = sourceSize;
          const sourceWidth = sourceHeight * cropRatio;
          const cropX = (sourceSize - sourceWidth) / 2;

          // Draw cropped and scaled
          ctx.drawImage(img, cropX, 0, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
        } else {
          // Non-square: just resize to fit
          ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
        }

        // Convert to JPG blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
        const filename = `${handle}_${idx + 1}_553x535.jpg`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to download CD image:', src, err);
        alert('Failed to process image. This may be due to CORS restrictions.');
      }
    }

    async function downloadResizedImage(src, handle, idx, hasTransparency = false) {
      try {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });

        // Create canvas at 1000x1000
        const canvas = document.createElement('canvas');
        canvas.width = 1000;
        canvas.height = 1000;
        const ctx = canvas.getContext('2d');

        // Get original format
        const ext = src.split('.').pop().split('?')[0].toLowerCase();
        const isPng = ext === 'png';

        // Only fill with white background if NOT a transparent PNG
        // Preserve transparency for transparent PNGs
        if (!isPng || !hasTransparency) {
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, 1000, 1000);
        }

        // Draw resized image
        ctx.drawImage(img, 0, 0, 1000, 1000);

        // Use PNG format if it's a transparent PNG, otherwise use original format logic
        const outputAsPng = isPng && hasTransparency;
        const mimeType = outputAsPng ? 'image/png' : (isPng ? 'image/png' : 'image/jpeg');
        const fileExt = outputAsPng ? 'png' : (isPng ? 'png' : 'jpg');

        const blob = await new Promise(resolve => canvas.toBlob(resolve, mimeType, 0.9));
        const filename = `${handle}_${idx + 1}_1000x1000.${fileExt}`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to resize image:', src, err);
        alert('Failed to process image. This may be due to CORS restrictions.');
      }
    }

    async function convertToPng(src, handle, idx) {
      try {
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = src;
        });

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');

        ctx.drawImage(img, 0, 0);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        const filename = `${handle}_${idx + 1}.png`;

        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);
      } catch (err) {
        console.error('Failed to convert to PNG:', src, err);
        alert('Failed to convert image. This may be due to CORS restrictions.');
      }
    }

    async function removeBackground(src, handle, idx, buttonEl) {
      try {
        // Update button state
        const originalText = buttonEl.textContent;
        buttonEl.disabled = true;
        buttonEl.textContent = 'Loading library...';

        // Lazy load the library only when needed
        if (!bgRemovalLoaded) {
          await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/@imgly/background-removal@1.4.5/dist/index.umd.js';
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
          });
          bgRemovalLoaded = true;
        }

        buttonEl.textContent = 'Fetching image...';

        // Fetch the image as a blob
        const response = await fetch(src);
        const inputBlob = await response.blob();

        buttonEl.textContent = 'Loading AI model...';

        // Remove background using imgly
        // The UMD build exports to window.imglyRemoveBackground or window.imglyRemoveBackground.removeBackground
        const removeBgFn = window.imglyRemoveBackground?.removeBackground ||
                          window.imglyRemoveBackground?.default ||
                          window.imglyRemoveBackground;

        if (!removeBgFn || typeof removeBgFn !== 'function') {
          console.log('Available on window.imglyRemoveBackground:', window.imglyRemoveBackground);
          throw new Error('Background removal function not found. Check console for details.');
        }

        const resultBlob = await removeBgFn(inputBlob, {
          progress: (key, current, total) => {
            if (key === 'compute:inference') {
              const pct = Math.round((current / total) * 100);
              buttonEl.textContent = `Processing ${pct}%`;
            }
          }
        });

        // Download the result
        const filename = `${handle}_${idx + 1}_nobg.png`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(resultBlob);
        link.download = filename;
        link.click();
        URL.revokeObjectURL(link.href);

        buttonEl.textContent = 'Done!';
        setTimeout(() => {
          buttonEl.disabled = false;
          buttonEl.textContent = originalText;
        }, 2000);
      } catch (err) {
        console.error('Failed to remove background:', src, err);
        alert('Failed to remove background: ' + err.message);
        buttonEl.disabled = false;
        buttonEl.textContent = 'Remove BG';
      }
    }

    let filterActive = false;
    let lastProducts = [];

    function toggleFilter() {
      filterActive = !filterActive;
      const btn = document.getElementById('filter-issues-btn');
      btn.classList.toggle('active', filterActive);
      btn.textContent = filterActive ? 'Show All' : 'Show Only Issues';

      // Toggle visibility of product cards without issues
      document.querySelectorAll('.product-card').forEach(card => {
        if (filterActive && card.classList.contains('all-good')) {
          card.classList.add('hidden');
        } else {
          card.classList.remove('hidden');
        }
      });
    }

    async function downloadIssueImages() {
      const btn = document.getElementById('download-btn');
      btn.disabled = true;
      btn.textContent = 'Downloading...';

      const imagesWithIssues = [];
      document.querySelectorAll('.product-card.has-issues').forEach(card => {
        const productUrl = card.querySelector('.product-url a')?.href || '';
        const handle = productUrl.split('/products/')[1] || 'unknown';

        card.querySelectorAll('.image-item').forEach((item, idx) => {
          const hasIssue = item.querySelector('.issues-list');
          if (hasIssue) {
            const imgSrc = item.querySelector('.image-thumb')?.src;
            if (imgSrc) {
              imagesWithIssues.push({ src: imgSrc, handle, idx });
            }
          }
        });
      });

      for (const img of imagesWithIssues) {
        try {
          const response = await fetch(img.src);
          const blob = await response.blob();
          const ext = img.src.split('.').pop().split('?')[0] || 'jpg';
          const filename = `${img.handle}_${img.idx + 1}.${ext}`;

          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = filename;
          link.click();
          URL.revokeObjectURL(link.href);

          // Small delay between downloads
          await new Promise(r => setTimeout(r, 300));
        } catch (err) {
          console.error('Failed to download:', img.src, err);
        }
      }

      btn.disabled = false;
      btn.textContent = 'Download All';
    }
  </script>
</body>
</html>
